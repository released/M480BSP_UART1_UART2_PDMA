; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Custom_Init||, CODE, READONLY, ALIGN=2

                  Custom_Init PROC
;;;721    
;;;722    void Custom_Init(void)
000000  b510              PUSH     {r4,lr}
;;;723    {
;;;724    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH0MFP_Msk)) | (SYS_GPH_MFPL_PH0MFP_GPIO);
000002  f04f4080          MOV      r0,#0x40000000
000006  6e81              LDR      r1,[r0,#0x68]
000008  f021010f          BIC      r1,r1,#0xf
00000c  6681              STR      r1,[r0,#0x68]
;;;725    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH1MFP_Msk)) | (SYS_GPH_MFPL_PH1MFP_GPIO);
00000e  6e81              LDR      r1,[r0,#0x68]
000010  f02101f0          BIC      r1,r1,#0xf0
000014  6681              STR      r1,[r0,#0x68]
;;;726    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH2MFP_Msk)) | (SYS_GPH_MFPL_PH2MFP_GPIO);
000016  6e81              LDR      r1,[r0,#0x68]
000018  f4216170          BIC      r1,r1,#0xf00
00001c  6681              STR      r1,[r0,#0x68]
;;;727    
;;;728    	//EVM LED
;;;729    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
00001e  4c09              LDR      r4,|L1.68|
000020  2201              MOVS     r2,#1
000022  4611              MOV      r1,r2
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GPIO_SetMode
;;;730    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00002a  2201              MOVS     r2,#1
00002c  2102              MOVS     r1,#2
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_SetMode
;;;731    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000034  4620              MOV      r0,r4
000036  2201              MOVS     r2,#1
000038  e8bd4010          POP      {r4,lr}
00003c  2104              MOVS     r1,#4
00003e  f7ffbffe          B.W      GPIO_SetMode
;;;732    	
;;;733    }
;;;734    
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  NVIC_SystemReset PROC
;;;1789    */
;;;1790   __STATIC_INLINE void NVIC_SystemReset(void)
000000  f3bf8f4f          DSB      
;;;1791   {
;;;1792     __DSB();                                                          /* Ensure all outstanding memory accesses included
;;;1793                                                                          buffered write are completed before reset */
;;;1794     SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
000004  4805              LDR      r0,|L3.28|
000006  6801              LDR      r1,[r0,#0]
000008  4a05              LDR      r2,|L3.32|
00000a  f40161e0          AND      r1,r1,#0x700
00000e  4311              ORRS     r1,r1,r2
000010  6001              STR      r1,[r0,#0]
;;;1795                              (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
;;;1796                               SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
;;;1797     __DSB();                                                          /* Ensure completion of memory access */
000012  f3bf8f4f          DSB      
                  |L3.22|
;;;1798   
;;;1799     for(;;)                                                           /* wait until reset */
;;;1800     {
;;;1801       __NOP();
000016  bf00              NOP      
000018  e7fd              B        |L3.22|
;;;1802     }
;;;1803   }
;;;1804   
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0xe000ed0c
                  |L3.32|
                          DCD      0x05fa0004

                          AREA ||i.PDMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  PDMA_IRQHandler PROC
;;;226    
;;;227    void PDMA_IRQHandler(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;228    {
;;;229        uint32_t status = PDMA_GET_INT_STATUS(PDMA);
000004  485a              LDR      r0,|L4.368|
000006  6800              LDR      r0,[r0,#0]
;;;230    
;;;231        #if defined (ENABLE_UART1) 
;;;232        UART1_P.cnt = PDMA_GET_TRANS_CNT(PDMA, UART1_RX_DMA_CH); /* channel transfer count */
000008  f8dfb168          LDR      r11,|L4.372|
00000c  f8db2000          LDR      r2,[r11,#0]
000010  f8df9164          LDR      r9,|L4.376|
000014  0c12              LSRS     r2,r2,#16
;;;233        #endif
;;;234    
;;;235        #if defined (ENABLE_UART2) 
;;;236        UART2_P.cnt = PDMA_GET_TRANS_CNT(PDMA, UART2_RX_DMA_CH); /* channel transfer count */
000016  f8c92058          STR      r2,[r9,#0x58]  ; UART1_P
00001a  f8db1010          LDR      r1,[r11,#0x10]
00001e  f1090a5c          ADD      r10,r9,#0x5c
000022  0c09              LSRS     r1,r1,#16
;;;237        #endif
;;;238    
;;;239        if (status & PDMA_INTSTS_ABTIF_Msk)   /* abort */
000024  f8ca1058          STR      r1,[r10,#0x58]  ; UART2_P
000028  07c3              LSLS     r3,r0,#31
00002a  d016              BEQ      |L4.90|
;;;240        {
;;;241            printf("target abort interrupt !!:\r\n");
00002c  a053              ADR      r0,|L4.380|
00002e  f7fffffe          BL       __2printf
;;;242    		#if 0
;;;243            PDMA_CLR_ABORT_FLAG(PDMA, PDMA_GET_ABORT_STS(PDMA));
;;;244    		#else
;;;245    
;;;246            #if defined (ENABLE_UART1)            
;;;247            if (PDMA_GET_ABORT_STS(PDMA) & (UART1_PDMA_OPENED_CH_RX))
000032  4c4f              LDR      r4,|L4.368|
000034  1d24              ADDS     r4,r4,#4
000036  6820              LDR      r0,[r4,#0]
000038  07c0              LSLS     r0,r0,#31
00003a  d004              BEQ      |L4.70|
;;;248            {
;;;249                printf("UART1_PDMA_OPENED_CH_RX\r\n");
00003c  a057              ADR      r0,|L4.412|
00003e  f7fffffe          BL       __2printf
;;;250                PDMA_CLR_ABORT_FLAG(PDMA, (UART1_PDMA_OPENED_CH_RX));
000042  2001              MOVS     r0,#1
000044  6020              STR      r0,[r4,#0]
                  |L4.70|
;;;251            }
;;;252            #endif
;;;253            
;;;254            #if defined (ENABLE_UART2) 
;;;255            if (PDMA_GET_ABORT_STS(PDMA) & (UART2_PDMA_OPENED_CH_RX))
000046  6820              LDR      r0,[r4,#0]
000048  0780              LSLS     r0,r0,#30
00004a  d504              BPL      |L4.86|
;;;256            {
;;;257                printf("UART2_PDMA_OPENED_CH_RX\r\n");
00004c  a05a              ADR      r0,|L4.440|
00004e  f7fffffe          BL       __2printf
;;;258                PDMA_CLR_ABORT_FLAG(PDMA, (UART2_PDMA_OPENED_CH_RX));
000052  2002              MOVS     r0,#2
000054  6020              STR      r0,[r4,#0]
                  |L4.86|
;;;259            }
;;;260            #endif
;;;261            
;;;262    		#endif
;;;263        }
;;;264        else if (status & PDMA_INTSTS_TDIF_Msk)     /* done */
;;;265        {
;;;266    		#if 1
;;;267    
;;;268            #if defined (ENABLE_UART1)            
;;;269            if (PDMA_GET_TD_STS(PDMA) & UART1_PDMA_OPENED_CH_RX)
;;;270            {
;;;271                PDMA_CLR_TD_FLAG(PDMA, UART1_PDMA_OPENED_CH_RX);
;;;272    
;;;273                /* Update receive count */
;;;274                UART1_P.g_u32comRbytes += UART1_P.g_u32cntbak + 1; /* count */
;;;275                UART1_P.g_u32comRtail = (UART1_P.g_u32comRtail + UART1_P.g_u32cntbak + 1) % RXBUFSIZE; /* index */
;;;276                UART1_P.g_u32cntbak = RXBUFSIZE / 2 - 1; /* channel cnt backup */
;;;277    
;;;278                UART1_P.g_u8PackageComplete = 1;
;;;279                
;;;280    			set_flag(flag_UART1_RX_end,ENABLE);
;;;281            } 
;;;282            #endif
;;;283    
;;;284            #if defined (ENABLE_UART2) 
;;;285            if (PDMA_GET_TD_STS(PDMA) & UART2_PDMA_OPENED_CH_RX)
;;;286            {
;;;287                PDMA_CLR_TD_FLAG(PDMA, UART2_PDMA_OPENED_CH_RX);
;;;288    
;;;289                /* Update receive count */
;;;290                UART2_P.g_u32comRbytes += UART2_P.g_u32cntbak + 1; /* count */
;;;291                UART2_P.g_u32comRtail = (UART2_P.g_u32comRtail + UART2_P.g_u32cntbak + 1) % RXBUFSIZE; /* index */
;;;292                UART2_P.g_u32cntbak = RXBUFSIZE / 2 - 1; /* channel cnt backup */
;;;293    
;;;294                UART2_P.g_u8PackageComplete = 1;
;;;295                
;;;296    			set_flag(flag_UART2_RX_end,ENABLE);
;;;297            } 
;;;298            #endif
;;;299    		
;;;300    		#else
;;;301            if((PDMA_GET_TD_STS(PDMA) & UART_PDMA_OPENED_CH) == UART_PDMA_OPENED_CH)
;;;302            {
;;;303                /* Clear PDMA transfer done interrupt flag */
;;;304                PDMA_CLR_TD_FLAG(PDMA, UART_PDMA_OPENED_CH);
;;;305    			//insert process
;;;306    			/*
;;;307                    DISABLE TRIGGER
;;;308                */
;;;309    
;;;310            } 
;;;311    		#endif
;;;312        }
;;;313        #if defined (ENABLE_UART1)     
;;;314        else if (status & (PDMA_INTSTS_REQTOF0_Msk))     /* Check the DMA time-out interrupt flag */
;;;315        {
;;;316            // printf("UART1_RX time-out !!\r\n");
;;;317            /* Update receive count */
;;;318            UART1_P.g_u32comRbytes += UART1_P.g_u32cntbak - UART1_P.cnt;  /* count */
;;;319            UART1_P.g_u32comRtail = (UART1_P.g_u32comRtail + UART1_P.g_u32cntbak - UART1_P.cnt) % RXBUFSIZE;  /* index */
;;;320            UART1_P.g_u32cntbak = UART1_P.cnt; /* channel cnt backup */
;;;321    
;;;322            UART1_P.g_u8PackageComplete = 0;
;;;323    
;;;324            /* restart timeout */
;;;325            PDMA_SetTimeOut(PDMA, UART1_RX_DMA_CH, DISABLE, 0);
;;;326            PDMA_CLR_TMOUT_FLAG(PDMA, UART1_RX_DMA_CH);
;;;327            PDMA_SetTimeOut(PDMA, UART1_RX_DMA_CH, ENABLE, PDMA_TIME);
;;;328        }
;;;329        #endif
;;;330        #if defined (ENABLE_UART2)     
;;;331        else if (status & (PDMA_INTSTS_REQTOF1_Msk))     /* Check the DMA time-out interrupt flag */
;;;332        {
;;;333            // printf("UART2_RX time-out !!\r\n");
;;;334            /* Update receive count */
;;;335            UART2_P.g_u32comRbytes += UART2_P.g_u32cntbak - UART2_P.cnt;  /* count */
;;;336            UART2_P.g_u32comRtail = (UART2_P.g_u32comRtail + UART2_P.g_u32cntbak - UART2_P.cnt) % RXBUFSIZE;  /* index */
;;;337            UART2_P.g_u32cntbak = UART2_P.cnt; /* channel cnt backup */
;;;338    
;;;339            UART2_P.g_u8PackageComplete = 0;
;;;340    
;;;341            /* restart timeout */
;;;342            PDMA_SetTimeOut(PDMA, UART2_RX_DMA_CH, DISABLE, 0);
;;;343            PDMA_CLR_TMOUT_FLAG(PDMA, UART2_RX_DMA_CH);
;;;344            PDMA_SetTimeOut(PDMA, UART2_RX_DMA_CH, ENABLE, PDMA_TIME);        
;;;345        }    
;;;346        #endif
;;;347        else
;;;348        {
;;;349            printf("unknown interrupt !!\r\n");
;;;350        }	
;;;351    }
000056  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.90|
00005a  4b47              LDR      r3,|L4.376|
00005c  ea5f7880          LSLS     r8,r0,#30             ;264
000060  e9d34612          LDRD     r4,r6,[r3,#0x48]      ;274
000064  6c1f              LDR      r7,[r3,#0x40]         ;275
000066  eb040306          ADD      r3,r4,r6              ;275
00006a  4c43              LDR      r4,|L4.376|
00006c  f104045c          ADD      r4,r4,#0x5c           ;236
000070  6c25              LDR      r5,[r4,#0x40]         ;290
000072  e9d4c412          LDRD     r12,r4,[r4,#0x48]     ;290
000076  44a4              ADD      r12,r12,r4            ;291
000078  d533              BPL      |L4.226|
00007a  493d              LDR      r1,|L4.368|
00007c  3108              ADDS     r1,r1,#8              ;269
00007e  6808              LDR      r0,[r1,#0]            ;269
000080  4a3d              LDR      r2,|L4.376|
000082  07c0              LSLS     r0,r0,#31             ;269
000084  f04f0b1f          MOV      r11,#0x1f             ;276
000088  f1a20208          SUB      r2,r2,#8              ;280
00008c  d012              BEQ      |L4.180|
00008e  f04f0801          MOV      r8,#1                 ;271
000092  f8c18000          STR      r8,[r1,#0]            ;271
000096  443e              ADD      r6,r6,r7              ;274
000098  1c76              ADDS     r6,r6,#1              ;274
00009a  1c5b              ADDS     r3,r3,#1              ;274
00009c  f003033f          AND      r3,r3,#0x3f           ;275
0000a0  f8c96040          STR      r6,[r9,#0x40]         ;275  ; UART1_P
0000a4  e9c93b12          STRD     r3,r11,[r9,#0x48]     ;275
0000a8  f8c98050          STR      r8,[r9,#0x50]         ;280  ; UART1_P
0000ac  6810              LDR      r0,[r2,#0]            ;280  ; BitFlag
0000ae  f0400002          ORR      r0,r0,#2              ;280
0000b2  6010              STR      r0,[r2,#0]            ;280  ; BitFlag
                  |L4.180|
0000b4  6808              LDR      r0,[r1,#0]            ;285
0000b6  0780              LSLS     r0,r0,#30             ;285
0000b8  d5cd              BPL      |L4.86|
0000ba  2002              MOVS     r0,#2                 ;287
0000bc  6008              STR      r0,[r1,#0]            ;287
0000be  1929              ADDS     r1,r5,r4              ;290
0000c0  1c49              ADDS     r1,r1,#1              ;290
0000c2  f10c0c01          ADD      r12,r12,#1            ;290
0000c6  f8ca1040          STR      r1,[r10,#0x40]        ;291  ; UART2_P
0000ca  f00c013f          AND      r1,r12,#0x3f          ;291
0000ce  e9ca1b12          STRD     r1,r11,[r10,#0x48]    ;291
0000d2  2101              MOVS     r1,#1                 ;294
0000d4  f8ca1050          STR      r1,[r10,#0x50]        ;296  ; UART2_P
0000d8  6810              LDR      r0,[r2,#0]            ;296  ; BitFlag
0000da  f0400004          ORR      r0,r0,#4              ;296
0000de  6010              STR      r0,[r2,#0]            ;296  ; BitFlag
0000e0  e7b9              B        |L4.86|
                  |L4.226|
0000e2  ea5f58c0          LSLS     r8,r0,#23             ;314
0000e6  f04f0e00          MOV      lr,#0                 ;314
0000ea  d51a              BPL      |L4.290|
0000ec  1ab1              SUBS     r1,r6,r2              ;318
0000ee  4439              ADD      r1,r1,r7              ;318
0000f0  f8c91040          STR      r1,[r9,#0x40]         ;319  ; UART1_P
0000f4  1a99              SUBS     r1,r3,r2              ;319
0000f6  f001013f          AND      r1,r1,#0x3f           ;319
0000fa  e9c91212          STRD     r1,r2,[r9,#0x48]      ;319
0000fe  2300              MOVS     r3,#0                 ;325
000100  461a              MOV      r2,r3                 ;325
000102  4619              MOV      r1,r3                 ;325
000104  465c              MOV      r4,r11                ;325
000106  4658              MOV      r0,r11                ;325
000108  f8c9e050          STR      lr,[r9,#0x50]         ;325  ; UART1_P
00010c  f7fffffe          BL       PDMA_SetTimeOut
000110  4917              LDR      r1,|L4.368|
000112  f44f7280          MOV      r2,#0x100             ;326
000116  600a              STR      r2,[r1,#0]            ;326
000118  2201              MOVS     r2,#1                 ;327
00011a  f2455355          MOV      r3,#0x5555            ;327
00011e  2100              MOVS     r1,#0                 ;327
000120  e01c              B        |L4.348|
                  |L4.290|
000122  0580              LSLS     r0,r0,#22             ;331
000124  d51f              BPL      |L4.358|
000126  1a62              SUBS     r2,r4,r1              ;335
000128  442a              ADD      r2,r2,r5              ;335
00012a  f8ca2040          STR      r2,[r10,#0x40]        ;336  ; UART2_P
00012e  ebac0201          SUB      r2,r12,r1             ;336
000132  f002023f          AND      r2,r2,#0x3f           ;336
000136  e9ca2112          STRD     r2,r1,[r10,#0x48]     ;336
00013a  2300              MOVS     r3,#0                 ;342
00013c  461a              MOV      r2,r3                 ;342
00013e  2101              MOVS     r1,#1                 ;342
000140  465c              MOV      r4,r11                ;342
000142  4658              MOV      r0,r11                ;342
000144  f8cae050          STR      lr,[r10,#0x50]        ;342  ; UART2_P
000148  f7fffffe          BL       PDMA_SetTimeOut
00014c  4908              LDR      r1,|L4.368|
00014e  f44f7200          MOV      r2,#0x200             ;343
000152  600a              STR      r2,[r1,#0]            ;343
000154  2201              MOVS     r2,#1                 ;344
000156  f2455355          MOV      r3,#0x5555            ;344
00015a  4611              MOV      r1,r2                 ;344
                  |L4.348|
00015c  4620              MOV      r0,r4                 ;344
00015e  e8bd5ff0          POP      {r4-r12,lr}           ;344
000162  f7ffbffe          B.W      PDMA_SetTimeOut
                  |L4.358|
000166  e8bd5ff0          POP      {r4-r12,lr}           ;349
00016a  a01a              ADR      r0,|L4.468|
00016c  f7ffbffe          B.W      __2printf
;;;352    
                          ENDP

                  |L4.368|
                          DCD      0x4000841c
                  |L4.372|
                          DCD      0x40008000
                  |L4.376|
                          DCD      ||.data||+0x8
                  |L4.380|
00017c  74617267          DCB      "target abort interrupt !!:\r\n",0
000180  65742061
000184  626f7274
000188  20696e74
00018c  65727275
000190  70742021
000194  213a0d0a
000198  00      
000199  00                DCB      0
00019a  00                DCB      0
00019b  00                DCB      0
                  |L4.412|
00019c  55415254          DCB      "UART1_PDMA_OPENED_CH_RX\r\n",0
0001a0  315f5044
0001a4  4d415f4f
0001a8  50454e45
0001ac  445f4348
0001b0  5f52580d
0001b4  0a00    
0001b6  00                DCB      0
0001b7  00                DCB      0
                  |L4.440|
0001b8  55415254          DCB      "UART2_PDMA_OPENED_CH_RX\r\n",0
0001bc  325f5044
0001c0  4d415f4f
0001c4  50454e45
0001c8  445f4348
0001cc  5f52580d
0001d0  0a00    
0001d2  00                DCB      0
0001d3  00                DCB      0
                  |L4.468|
0001d4  756e6b6e          DCB      "unknown interrupt !!\r\n",0
0001d8  6f776e20
0001dc  696e7465
0001e0  72727570
0001e4  74202121
0001e8  0d0a00  
0001eb  00                DCB      0

                          AREA ||i.PDMA_WriteUART1SGTable||, CODE, READONLY, ALIGN=2

                  PDMA_WriteUART1SGTable PROC
;;;411    
;;;412    void PDMA_WriteUART1SGTable(void)  //scatter-gather table */
000000  480b              LDR      r0,|L5.48|
;;;413    {
000002  b510              PUSH     {r4,lr}
;;;414        DMA_UART1DESC[UART1_RX_BUFFER01].ctl = \
000004  4b09              LDR      r3,|L5.44|
;;;415                          ((RXBUFSIZE / 2 - 1) << PDMA_DSCT_CTL_TXCNT_Pos) | /* Transfer count is RXBUFSIZE/2 */ \
;;;416                          PDMA_WIDTH_8 |    /* Transfer width is 8 bits */ \
;;;417                          PDMA_SAR_FIX |    /* Source increment size is  fixed(no increment) */ \
;;;418                          PDMA_DAR_INC |    /* Destination increment size is 8 bits */ \
;;;419                          PDMA_REQ_SINGLE | /* Transfer type is single transfer type */ \
;;;420                          PDMA_BURST_1 |    /* Burst size is 1. No effect in single transfer type */ \
;;;421                          PDMA_OP_SCATTER;  /* Operation mode is scatter-gather mode */
;;;422        /* Configure source address */
;;;423        DMA_UART1DESC[UART1_RX_BUFFER01].src = (uint32_t)UART1_BASE;
;;;424        /* Configure destination address */
;;;425        DMA_UART1DESC[UART1_RX_BUFFER01].dest = (uint32_t)&UART1_P.g_u8RecData[0];/*buffer 1 */
000006  4a0c              LDR      r2,|L5.56|
000008  490a              LDR      r1,|L5.52|
00000a  6003              STR      r3,[r0,#0]  ; DMA_UART1DESC
00000c  e9c01201          STRD     r1,r2,[r0,#4]
;;;426        /* Configure next descriptor table address */
;;;427        DMA_UART1DESC[UART1_RX_BUFFER01].offset = (uint32_t)&DMA_UART1DESC[UART1_RX_BUFFER02] - (PDMA->SCATBA); /* next operation table is table 2 */
000010  4a0a              LDR      r2,|L5.60|
000012  6814              LDR      r4,[r2,#0]
000014  1b04              SUBS     r4,r0,r4
000016  3410              ADDS     r4,r4,#0x10
000018  60c4              STR      r4,[r0,#0xc]  ; DMA_UART1DESC
00001a  e9c03104          STRD     r3,r1,[r0,#0x10]
;;;428    
;;;429        DMA_UART1DESC[UART1_RX_BUFFER02].ctl = \
;;;430                          ((RXBUFSIZE / 2 - 1) << PDMA_DSCT_CTL_TXCNT_Pos) | /* Transfer count is RXBUFSIZE/2 */ \
;;;431                          PDMA_WIDTH_8 |    /* Transfer width is 8 bits */ \
;;;432                          PDMA_SAR_FIX |    /* Source increment size is fixed(no increment) */ \
;;;433                          PDMA_DAR_INC |    /* Destination increment size is 8 bits */ \
;;;434                          PDMA_REQ_SINGLE | /* Transfer type is single transfer type */ \
;;;435                          PDMA_BURST_1 |    /* Burst size is 1. No effect in single transfer type */ \
;;;436                          PDMA_OP_SCATTER;  /* Operation mode is scatter-gather mode */
;;;437        /* Configure source address */
;;;438        DMA_UART1DESC[UART1_RX_BUFFER02].src = (uint32_t)UART1_BASE;
;;;439        /* Configure destination address */
;;;440        DMA_UART1DESC[UART1_RX_BUFFER02].dest = (uint32_t)&UART1_P.g_u8RecData[RXBUFSIZE / 2] ; /* buffer 2 */
00001e  4906              LDR      r1,|L5.56|
000020  3120              ADDS     r1,r1,#0x20
;;;441        /* Configure next descriptor table address */
;;;442        DMA_UART1DESC[UART1_RX_BUFFER02].offset = (uint32_t)&DMA_UART1DESC[UART1_RX_BUFFER01] - (PDMA->SCATBA); /* next operation table is table 1 */
000022  6181              STR      r1,[r0,#0x18]  ; DMA_UART1DESC
000024  6811              LDR      r1,[r2,#0]
000026  1a41              SUBS     r1,r0,r1
000028  61c1              STR      r1,[r0,#0x1c]  ; DMA_UART1DESC
;;;443    }
00002a  bd10              POP      {r4,pc}
;;;444    
                          ENDP

                  |L5.44|
                          DCD      0x001f0376
                  |L5.48|
                          DCD      ||.bss||
                  |L5.52|
                          DCD      0x40071000
                  |L5.56|
                          DCD      ||.data||+0x8
                  |L5.60|
                          DCD      0x4000843c

                          AREA ||i.PDMA_WriteUART2SGTable||, CODE, READONLY, ALIGN=2

                  PDMA_WriteUART2SGTable PROC
;;;377    
;;;378    void PDMA_WriteUART2SGTable(void)  //scatter-gather table */
000000  480b              LDR      r0,|L6.48|
;;;379    {
000002  b510              PUSH     {r4,lr}
;;;380        DMA_UART2DESC[UART2_RX_BUFFER01].ctl = \
000004  4b09              LDR      r3,|L6.44|
;;;381                          ((RXBUFSIZE / 2 - 1) << PDMA_DSCT_CTL_TXCNT_Pos) | /* Transfer count is RXBUFSIZE/2 */ \
;;;382                          PDMA_WIDTH_8 |    /* Transfer width is 8 bits */ \
;;;383                          PDMA_SAR_FIX |    /* Source increment size is  fixed(no increment) */ \
;;;384                          PDMA_DAR_INC |    /* Destination increment size is 8 bits */ \
;;;385                          PDMA_REQ_SINGLE | /* Transfer type is single transfer type */ \
;;;386                          PDMA_BURST_1 |    /* Burst size is 1. No effect in single transfer type */ \
;;;387                          PDMA_OP_SCATTER;  /* Operation mode is scatter-gather mode */
;;;388        /* Configure source address */
;;;389        DMA_UART2DESC[UART2_RX_BUFFER01].src = (uint32_t)UART2_BASE;
;;;390        /* Configure destination address */
;;;391        DMA_UART2DESC[UART2_RX_BUFFER01].dest = (uint32_t)&UART2_P.g_u8RecData[0];/*buffer 1 */
000006  4a0c              LDR      r2,|L6.56|
000008  490a              LDR      r1,|L6.52|
00000a  6003              STR      r3,[r0,#0]  ; DMA_UART2DESC
00000c  e9c01201          STRD     r1,r2,[r0,#4]
;;;392        /* Configure next descriptor table address */
;;;393        DMA_UART2DESC[UART2_RX_BUFFER01].offset = (uint32_t)&DMA_UART2DESC[UART2_RX_BUFFER02] - (PDMA->SCATBA); /* next operation table is table 2 */
000010  4a0a              LDR      r2,|L6.60|
000012  6814              LDR      r4,[r2,#0]
000014  1b04              SUBS     r4,r0,r4
000016  3410              ADDS     r4,r4,#0x10
000018  60c4              STR      r4,[r0,#0xc]  ; DMA_UART2DESC
00001a  e9c03104          STRD     r3,r1,[r0,#0x10]
;;;394    
;;;395        DMA_UART2DESC[UART2_RX_BUFFER02].ctl = \
;;;396                          ((RXBUFSIZE / 2 - 1) << PDMA_DSCT_CTL_TXCNT_Pos) | /* Transfer count is RXBUFSIZE/2 */ \
;;;397                          PDMA_WIDTH_8 |    /* Transfer width is 8 bits */ \
;;;398                          PDMA_SAR_FIX |    /* Source increment size is fixed(no increment) */ \
;;;399                          PDMA_DAR_INC |    /* Destination increment size is 8 bits */ \
;;;400                          PDMA_REQ_SINGLE | /* Transfer type is single transfer type */ \
;;;401                          PDMA_BURST_1 |    /* Burst size is 1. No effect in single transfer type */ \
;;;402                          PDMA_OP_SCATTER;  /* Operation mode is scatter-gather mode */
;;;403        /* Configure source address */
;;;404        DMA_UART2DESC[UART2_RX_BUFFER02].src = (uint32_t)UART2_BASE;
;;;405        /* Configure destination address */
;;;406        DMA_UART2DESC[UART2_RX_BUFFER02].dest = (uint32_t)&UART2_P.g_u8RecData[RXBUFSIZE / 2] ; /* buffer 2 */
00001e  4906              LDR      r1,|L6.56|
000020  3120              ADDS     r1,r1,#0x20
;;;407        /* Configure next descriptor table address */
;;;408        DMA_UART2DESC[UART2_RX_BUFFER02].offset = (uint32_t)&DMA_UART2DESC[UART2_RX_BUFFER01] - (PDMA->SCATBA); /* next operation table is table 1 */
000022  6181              STR      r1,[r0,#0x18]  ; DMA_UART2DESC
000024  6811              LDR      r1,[r2,#0]
000026  1a41              SUBS     r1,r0,r1
000028  61c1              STR      r1,[r0,#0x1c]  ; DMA_UART2DESC
;;;409    
;;;410    }
00002a  bd10              POP      {r4,pc}
;;;411    
                          ENDP

                  |L6.44|
                          DCD      0x001f0376
                  |L6.48|
                          DCD      ||.bss||+0x20
                  |L6.52|
                          DCD      0x40072000
                  |L6.56|
                          DCD      ||.data||+0x64
                  |L6.60|
                          DCD      0x4000843c

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;734    
;;;735    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  0784              LSLS     r4,r0,#30
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L7.10|
00000a  f8c40100          STR      r0,[r4,#0x100]
00000e  f8c41100          STR      r1,[r4,#0x100]
000012  f8c42100          STR      r2,[r4,#0x100]
000016  f8d43100          LDR      r3,[r4,#0x100]
00001a  2b00              CMP      r3,#0
00001c  d0f5              BEQ      |L7.10|
;;;736    {
;;;737        /* Unlock protected registers */
;;;738        SYS_UnlockReg();
;;;739    
;;;740        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;741        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
00001e  f04f2040          MOV      r0,#0x40004000
000022  f8d01140          LDR      r1,[r0,#0x140]
000026  f02101f0          BIC      r1,r1,#0xf0
00002a  f8c01140          STR      r1,[r0,#0x140]
;;;742    
;;;743        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
00002e  2004              MOVS     r0,#4
000030  f7fffffe          BL       CLK_EnableXtalRC
;;;744        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000034  2010              MOVS     r0,#0x10
000036  f7fffffe          BL       CLK_WaitClockReady
;;;745    
;;;746    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;747    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;748    
;;;749    //    CLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);
;;;750    //    CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
;;;751    
;;;752    //    CLK_EnableXtalRC(CLK_PWRCTL_LXTEN_Msk);
;;;753    //    CLK_WaitClockReady(CLK_STATUS_LXTSTB_Msk);
;;;754    
;;;755        /* Set core clock as PLL_CLOCK from PLL */
;;;756        CLK_SetCoreClock(FREQ_192MHZ);
00003a  4827              LDR      r0,|L7.216|
00003c  f7fffffe          BL       CLK_SetCoreClock
;;;757        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;758        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000040  2011              MOVS     r0,#0x11
000042  f8c40234          STR      r0,[r4,#0x234]
;;;759    
;;;760        CLK_EnableModuleClock(PDMA_MODULE);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       CLK_EnableModuleClock
;;;761    
;;;762        /* Enable UART clock */
;;;763        CLK_EnableModuleClock(UART0_MODULE);
00004c  4e23              LDR      r6,|L7.220|
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       CLK_EnableModuleClock
;;;764        /* Select UART clock source from HXT */
;;;765        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
000054  f04f7540          MOV      r5,#0x3000000
000058  2200              MOVS     r2,#0
00005a  4629              MOV      r1,r5
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       CLK_SetModuleClock
;;;766    
;;;767        #if defined (ENABLE_UART1) 
;;;768        CLK_EnableModuleClock(UART1_MODULE);
000062  4e1f              LDR      r6,|L7.224|
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       CLK_EnableModuleClock
;;;769        /* Select UART clock source from HXT */
;;;770        CLK_SetModuleClock(UART1_MODULE, CLK_CLKSEL1_UART1SEL_HIRC, CLK_CLKDIV0_UART1(1));
00006a  2200              MOVS     r2,#0
00006c  00a9              LSLS     r1,r5,#2
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       CLK_SetModuleClock
;;;771        #endif
;;;772    
;;;773        #if defined (ENABLE_UART2) 
;;;774        CLK_EnableModuleClock(UART2_MODULE);
000074  4e1b              LDR      r6,|L7.228|
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       CLK_EnableModuleClock
;;;775        /* Select UART clock source from HXT */
;;;776        CLK_SetModuleClock(UART2_MODULE, CLK_CLKSEL3_UART2SEL_HIRC, CLK_CLKDIV4_UART2(1));
00007c  2200              MOVS     r2,#0
00007e  4629              MOV      r1,r5
000080  4630              MOV      r0,r6
000082  f7fffffe          BL       CLK_SetModuleClock
;;;777        #endif
;;;778    
;;;779        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;780        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000086  6be0              LDR      r0,[r4,#0x3c]
000088  f420007f          BIC      r0,r0,#0xff0000
00008c  63e0              STR      r0,[r4,#0x3c]
;;;781        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00008e  6be0              LDR      r0,[r4,#0x3c]
000090  f44000cc          ORR      r0,r0,#0x660000
000094  63e0              STR      r0,[r4,#0x3c]
;;;782    
;;;783        #if defined (ENABLE_UART1) 
;;;784        SYS->GPA_MFPL &= ~(SYS_GPA_MFPL_PA2MFP_Msk);
000096  6b20              LDR      r0,[r4,#0x30]
000098  f4206070          BIC      r0,r0,#0xf00
00009c  6320              STR      r0,[r4,#0x30]
;;;785        SYS->GPA_MFPL |= SYS_GPA_MFPL_PA2MFP_UART1_RXD;
00009e  6b20              LDR      r0,[r4,#0x30]
0000a0  f4406000          ORR      r0,r0,#0x800
0000a4  6320              STR      r0,[r4,#0x30]
;;;786        #endif
;;;787    
;;;788        #if defined (ENABLE_UART2) 
;;;789        SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB0MFP_Msk);
0000a6  6ba0              LDR      r0,[r4,#0x38]
0000a8  f020000f          BIC      r0,r0,#0xf
0000ac  63a0              STR      r0,[r4,#0x38]
;;;790        SYS->GPB_MFPL |= SYS_GPB_MFPL_PB0MFP_UART2_RXD;    
0000ae  6ba0              LDR      r0,[r4,#0x38]
0000b0  f0400007          ORR      r0,r0,#7
0000b4  63a0              STR      r0,[r4,#0x38]
;;;791        #endif
;;;792    
;;;793        CLK_EnableModuleClock(TMR1_MODULE);
0000b6  4d0c              LDR      r5,|L7.232|
0000b8  4628              MOV      r0,r5
0000ba  f7fffffe          BL       CLK_EnableModuleClock
;;;794        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
0000be  2200              MOVS     r2,#0
0000c0  f44f41e0          MOV      r1,#0x7000
0000c4  4628              MOV      r0,r5
0000c6  f7fffffe          BL       CLK_SetModuleClock
;;;795    	
;;;796        /* Update System Core Clock */
;;;797        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;798        SystemCoreClockUpdate();
0000ca  f7fffffe          BL       SystemCoreClockUpdate
0000ce  2000              MOVS     r0,#0
0000d0  f8c40100          STR      r0,[r4,#0x100]
;;;799    
;;;800        /* Lock protected registers */
;;;801        SYS_LockReg();
;;;802    }
0000d4  bd70              POP      {r4-r6,pc}
;;;803    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L7.216|
                          DCD      0x0b71b000
                  |L7.220|
                          DCD      0x57803d10
                  |L7.224|
                          DCD      0x57a03d91
                  |L7.228|
                          DCD      0x778c3c12
                  |L7.232|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;635    
;;;636    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;637    {
;;;638        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L8.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;639        TIMER_EnableInt(TIMER1);
;;;640        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;641        TIMER_Start(TIMER1);
;;;642    }
000028  bd10              POP      {r4,pc}
;;;643    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;612    
;;;613    void TMR1_IRQHandler(void)
000000  480d              LDR      r0,|L9.56|
;;;614    {
000002  b500              PUSH     {lr}
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
00000a  2900              CMP      r1,#0
00000c  d012              BEQ      |L9.52|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;615    	// static uint32_t LOG = 0;
;;;616    	
;;;617        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;618        {
;;;619            TIMER_ClearIntFlag(TIMER1);
;;;620    		tick_counter();
000012  f7fffffe          BL       tick_counter
000016  4a09              LDR      r2,|L9.60|
000018  6850              LDR      r0,[r2,#4]  ; counter_tick
;;;621    
;;;622    		if ((get_tick() % 1000) == 0)
00001a  f44f717a          MOV      r1,#0x3e8
00001e  fbb0f3f1          UDIV     r3,r0,r1
000022  fb010013          MLS      r0,r1,r3,r0
000026  b920              CBNZ     r0,|L9.50|
;;;623    		{
;;;624    			// printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;625    			PH0 ^= 1;
000028  4805              LDR      r0,|L9.64|
00002a  6801              LDR      r1,[r0,#0]
00002c  f0810101          EOR      r1,r1,#1
000030  6001              STR      r1,[r0,#0]
                  |L9.50|
000032  6850              LDR      r0,[r2,#4]  ; counter_tick
                  |L9.52|
;;;626    		}
;;;627    
;;;628    		if ((get_tick() % 50) == 0)
;;;629    		{
;;;630    
;;;631    		}	
;;;632        }
;;;633    }
000034  bd00              POP      {pc}
;;;634    
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      0x40050100
                  |L9.60|
                          DCD      ||.data||
                  |L9.64|
                          DCD      0x400049c0

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;675    
;;;676    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;677    {
;;;678        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L10.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L10.18|
00000c  e004              B        |L10.24|
                  |L10.14|
;;;679        {
;;;680            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;681            {
;;;682    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L10.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;680
000014  0449              LSLS     r1,r1,#17             ;680
000016  d5fa              BPL      |L10.14|
                  |L10.24|
;;;683            }
;;;684        }
;;;685    
;;;686        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L10.46|
;;;687        {
;;;688            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L10.46|
;;;689        }	
;;;690    }
00002e  bd10              POP      {r4,pc}
;;;691    
                          ENDP

                  |L10.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;691    
;;;692    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;693    {
;;;694        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L11.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;695    
;;;696        /* Configure UART0 and set UART0 baud rate */
;;;697        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L11.128|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;698    
;;;699    	/* Set UART receive time-out */
;;;700    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;701    
;;;702    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;703    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;704    
;;;705    	/* Enable UART Interrupt - */
;;;706    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;707    	
;;;708    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;709    
;;;710    	#if (_debug_log_UART_ == 1)	//debug
;;;711    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a010              ADR      r0,|L11.132|
000044  f7fffffe          BL       __2printf
;;;712    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000048  f7fffffe          BL       CLK_GetHXTFreq
00004c  4601              MOV      r1,r0
00004e  a014              ADR      r0,|L11.160|
000050  f7fffffe          BL       __2printf
;;;713    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000054  f7fffffe          BL       CLK_GetLXTFreq
000058  4601              MOV      r1,r0
00005a  a017              ADR      r0,|L11.184|
00005c  f7fffffe          BL       __2printf
;;;714    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000060  f7fffffe          BL       CLK_GetPCLK0Freq
000064  4601              MOV      r1,r0
000066  a01a              ADR      r0,|L11.208|
000068  f7fffffe          BL       __2printf
;;;715    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
00006c  f7fffffe          BL       CLK_GetPCLK1Freq
000070  4601              MOV      r1,r0
000072  e8bd4010          POP      {r4,lr}
000076  a01d              ADR      r0,|L11.236|
000078  f7ffbffe          B.W      __2printf
;;;716    
;;;717    //    printf("Product ID 0x%8X\n", SYS->PDID);
;;;718    	
;;;719    	#endif
;;;720    }
;;;721    
                          ENDP

                  |L11.124|
                          DCD      0x04000010
                  |L11.128|
                          DCD      0x40070000
                  |L11.132|
000084  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000088  4b5f4765
00008c  74435055
000090  46726571
000094  203a2025
000098  38640d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L11.160|
0000a0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a4  47657448
0000a8  58544672
0000ac  6571203a
0000b0  20253864
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L11.184|
0000b8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000bc  4765744c
0000c0  58544672
0000c4  6571203a
0000c8  20253864
0000cc  0d0a00  
0000cf  00                DCB      0
                  |L11.208|
0000d0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d4  47657450
0000d8  434c4b30
0000dc  46726571
0000e0  203a2025
0000e4  38640d0a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L11.236|
0000ec  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f0  47657450
0000f4  434c4b31
0000f8  46726571
0000fc  203a2025
000100  38640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.UART1_UART2_Init||, CODE, READONLY, ALIGN=2

                  UART1_UART2_Init PROC
;;;356    */
;;;357    void UART1_UART2_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;358    {
;;;359        #if defined (ENABLE_UART1)     
;;;360        SYS_ResetModule(UART1_RST);
000002  480e              LDR      r0,|L12.60|
000004  f7fffffe          BL       SYS_ResetModule
;;;361        UART_Open(UART1, 115200);
000008  4c0d              LDR      r4,|L12.64|
00000a  f44f35e1          MOV      r5,#0x1c200
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       UART_Open
;;;362        #endif
;;;363    
;;;364        #if defined (ENABLE_UART2)     
;;;365        SYS_ResetModule(UART2_RST);    
000016  4809              LDR      r0,|L12.60|
000018  1c40              ADDS     r0,r0,#1
00001a  f7fffffe          BL       SYS_ResetModule
;;;366        UART_Open(UART2, 115200);
00001e  4629              MOV      r1,r5
000020  4d08              LDR      r5,|L12.68|
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       UART_Open
;;;367        #endif
;;;368    
;;;369        #if defined (ENABLE_UART1)
;;;370        UART_PDMA_ENABLE(UART1,UART_INTEN_RXPDMAEN_Msk);
000028  6860              LDR      r0,[r4,#4]
00002a  f4404000          ORR      r0,r0,#0x8000
00002e  6060              STR      r0,[r4,#4]
;;;371        #endif
;;;372    
;;;373        #if defined (ENABLE_UART2)     
;;;374        UART_PDMA_ENABLE(UART2,UART_INTEN_RXPDMAEN_Msk);
000030  6868              LDR      r0,[r5,#4]
000032  f4404000          ORR      r0,r0,#0x8000
000036  6068              STR      r0,[r5,#4]
;;;375        #endif
;;;376    }
000038  bd70              POP      {r4-r6,pc}
;;;377    
                          ENDP

00003a  0000              DCW      0x0000
                  |L12.60|
                          DCD      0x04000011
                  |L12.64|
                          DCD      0x40071000
                  |L12.68|
                          DCD      0x40072000

                          AREA ||i.UART_PDMA_Init||, CODE, READONLY, ALIGN=2

                  UART_PDMA_Init PROC
;;;444    
;;;445    void UART_PDMA_Init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;446    {
;;;447    	set_flag(flag_UART1_RX_end,DISABLE);
000002  4828              LDR      r0,|L13.164|
000004  6801              LDR      r1,[r0,#0]  ; BitFlag
000006  f0210102          BIC      r1,r1,#2
00000a  6001              STR      r1,[r0,#0]  ; BitFlag
;;;448    	set_flag(flag_UART2_RX_end,DISABLE);
00000c  6801              LDR      r1,[r0,#0]  ; BitFlag
00000e  f0210104          BIC      r1,r1,#4
000012  6001              STR      r1,[r0,#0]  ; BitFlag
;;;449    
;;;450        SYS_ResetModule(PDMA_RST);
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       SYS_ResetModule
;;;451    
;;;452        #if defined (ENABLE_UART1)    
;;;453        PDMA_Open(PDMA, UART1_PDMA_OPENED_CH_RX);
00001a  4c23              LDR      r4,|L13.168|
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       PDMA_Open
;;;454        #endif
;;;455    
;;;456        #if defined (ENABLE_UART2)     
;;;457        PDMA_Open(PDMA, UART2_PDMA_OPENED_CH_RX);
000024  2102              MOVS     r1,#2
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       PDMA_Open
;;;458        #endif
;;;459        
;;;460        // UART1 RX
;;;461        #if 1
;;;462    
;;;463        #if defined (ENABLE_UART1)    
;;;464        PDMA_WriteUART1SGTable();
00002c  f7fffffe          BL       PDMA_WriteUART1SGTable
;;;465        PDMA_SetTransferMode(PDMA, UART1_RX_DMA_CH, PDMA_UART1_RX, TRUE, (uint32_t)&DMA_UART1DESC[UART1_RX_BUFFER01]);
000030  491e              LDR      r1,|L13.172|
000032  9100              STR      r1,[sp,#0]
000034  2301              MOVS     r3,#1
000036  2207              MOVS     r2,#7
000038  2100              MOVS     r1,#0
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       PDMA_SetTransferMode
;;;466        #endif
;;;467    
;;;468        #if defined (ENABLE_UART2)
;;;469        PDMA_WriteUART2SGTable();
000040  f7fffffe          BL       PDMA_WriteUART2SGTable
;;;470        PDMA_SetTransferMode(PDMA, UART2_RX_DMA_CH, PDMA_UART2_RX, TRUE, (uint32_t)&DMA_UART2DESC[UART2_RX_BUFFER01]);
000044  4919              LDR      r1,|L13.172|
000046  2301              MOVS     r3,#1
000048  3120              ADDS     r1,r1,#0x20
00004a  9100              STR      r1,[sp,#0]
00004c  2209              MOVS     r2,#9
00004e  4619              MOV      r1,r3
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       PDMA_SetTransferMode
;;;471    
;;;472        #endif
;;;473    
;;;474    
;;;475        #else
;;;476        PDMA_SetTransferCnt(PDMA,UART1_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
;;;477        /* Set source/destination address and attributes */
;;;478        PDMA_SetTransferAddr(PDMA,UART1_RX_DMA_CH, UART1_BASE, PDMA_SAR_FIX, ((uint32_t) (&UART1_RxBuffer[0])), PDMA_DAR_INC);
;;;479    
;;;480        /* Set request source; set basic mode. */
;;;481        PDMA_SetTransferMode(PDMA,UART1_RX_DMA_CH, PDMA_UART1_RX, FALSE, 0);
;;;482        /* Single request type. */
;;;483        PDMA_SetBurstType(PDMA,UART1_RX_DMA_CH, PDMA_REQ_SINGLE, 0);
;;;484        /* Disable table interrupt */
;;;485        PDMA_DisableInt(PDMA,UART1_RX_DMA_CH, PDMA_INT_TEMPTY );//PDMA->DSCT[UART1_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
;;;486    
;;;487        // UART2 RX	
;;;488        PDMA_SetTransferCnt(PDMA,UART2_RX_DMA_CH, PDMA_WIDTH_8, DATA_NUM);
;;;489        /* Set source/destination address and attributes */
;;;490        PDMA_SetTransferAddr(PDMA,UART2_RX_DMA_CH, UART2_BASE, PDMA_SAR_FIX, ((uint32_t) (&UART2_RxBuffer[0])), PDMA_DAR_INC);
;;;491        /* Set request source; set basic mode. */
;;;492        PDMA_SetTransferMode(PDMA,UART2_RX_DMA_CH, PDMA_UART2_RX, FALSE, 0);
;;;493        /* Single request type. */
;;;494        PDMA_SetBurstType(PDMA,UART2_RX_DMA_CH, PDMA_REQ_SINGLE, 0);
;;;495        /* Disable table interrupt */
;;;496        PDMA_DisableInt(PDMA,UART2_RX_DMA_CH, PDMA_INT_TEMPTY );//PDMA->DSCT[UART2_RX_DMA_CH].CTL |= PDMA_DSCT_CTL_TBINTDIS_Msk;
;;;497        #endif
;;;498        /*
;;;499            UART data freq : 1.6KHz	0.625	ms
;;;500    
;;;501            Set PDMA CH 0/1 timeout to about 
;;;502            2 ms (5/(72M/(2^15)))
;;;503            0.56 ms (5/(72M/(2^13)))
;;;504    
;;;505            target (ms)	    u32TimeOutCnt	clk div	    prescale	
;;;506            2.275555556	    5	            72000000	32768	15      111
;;;507            1.137777778	    5	            72000000	16384	14      110
;;;508            0.568888889	    5	            72000000	8192	13      101
;;;509            0.284444444	    5	            72000000	4096	12      100
;;;510            0.142222222	    5	            72000000	2048	11      011
;;;511            0.071111111	    5	            72000000	1024	10      010
;;;512            0.035555556	    5	            72000000	512	    9       001
;;;513            0.017777778	    5	            72000000	256	    8       000  
;;;514    
;;;515        */
;;;516        // PDMA->TOUTPSC = (PDMA->TOUTPSC & (~PDMA_TOUTPSC_TOUTPSC0_Msk)) | (0x5 << PDMA_TOUTPSC_TOUTPSC0_Pos);
;;;517        PDMA_SetTimeOut(PDMA,UART1_RX_DMA_CH, ENABLE, PDMA_TIME );
000056  f2455555          MOV      r5,#0x5555
00005a  462b              MOV      r3,r5
00005c  2201              MOVS     r2,#1
00005e  2100              MOVS     r1,#0
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       PDMA_SetTimeOut
;;;518    
;;;519        #if defined (ENABLE_UART2) 
;;;520        // PDMA->TOUTPSC = (PDMA->TOUTPSC & (~PDMA_TOUTPSC_TOUTPSC1_Msk)) | (0x5 << PDMA_TOUTPSC_TOUTPSC1_Pos);
;;;521        PDMA_SetTimeOut(PDMA,UART2_RX_DMA_CH, ENABLE, PDMA_TIME );
000066  2201              MOVS     r2,#1
000068  462b              MOV      r3,r5
00006a  4611              MOV      r1,r2
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       PDMA_SetTimeOut
;;;522        #endif
;;;523    
;;;524        // UART_PDMA_ENABLE(UART1,UART_INTEN_RXPDMAEN_Msk);
;;;525        // UART_PDMA_ENABLE(UART2,UART_INTEN_RXPDMAEN_Msk);
;;;526    
;;;527        PDMA_EnableInt(PDMA, UART1_RX_DMA_CH, PDMA_INT_TRANS_DONE);
000072  2200              MOVS     r2,#0
000074  4611              MOV      r1,r2
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       PDMA_EnableInt
;;;528        PDMA_EnableInt(PDMA, UART1_RX_DMA_CH, PDMA_INT_TIMEOUT);
00007c  2202              MOVS     r2,#2
00007e  2100              MOVS     r1,#0
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       PDMA_EnableInt
;;;529        #if defined (ENABLE_UART2)    
;;;530        PDMA_EnableInt(PDMA, UART2_RX_DMA_CH, PDMA_INT_TRANS_DONE);
000086  2200              MOVS     r2,#0
000088  2101              MOVS     r1,#1
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       PDMA_EnableInt
;;;531        PDMA_EnableInt(PDMA, UART2_RX_DMA_CH, PDMA_INT_TIMEOUT);
000090  2202              MOVS     r2,#2
000092  2101              MOVS     r1,#1
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       PDMA_EnableInt
;;;532        #endif
;;;533        NVIC_EnableIRQ(PDMA_IRQn);
00009a  e8bd4038          POP      {r3-r5,lr}
00009e  2028              MOVS     r0,#0x28
0000a0  f7ffbffe          B.W      NVIC_EnableIRQ
;;;534    
;;;535    }
;;;536    
                          ENDP

                  |L13.164|
                          DCD      ||.data||
                  |L13.168|
                          DCD      0x40008000
                  |L13.172|
                          DCD      ||.bss||

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                  UARTx_Process PROC
;;;643    
;;;644    void UARTx_Process(void)
000000  480e              LDR      r0,|L14.60|
;;;645    {
000002  b510              PUSH     {r4,lr}
;;;646    	uint8_t res = 0;
;;;647    	res = UART_READ(UART0);
000004  6800              LDR      r0,[r0,#0]
000006  b2c0              UXTB     r0,r0
;;;648    
;;;649    	if (res == 'x' || res == 'X')
000008  2878              CMP      r0,#0x78
00000a  d014              BEQ      |L14.54|
00000c  2858              CMP      r0,#0x58
00000e  d012              BEQ      |L14.54|
;;;650    	{
;;;651    		NVIC_SystemReset();
;;;652    	}
;;;653    
;;;654    	if (res > 0x7F)
000010  287f              CMP      r0,#0x7f
000012  d904              BLS      |L14.30|
;;;655    	{
;;;656    		printf("invalid command\r\n");
000014  e8bd4010          POP      {r4,lr}
000018  a009              ADR      r0,|L14.64|
00001a  f7ffbffe          B.W      __2printf
                  |L14.30|
;;;657    	}
;;;658    	else
;;;659    	{
;;;660    		switch(res)
00001e  285a              CMP      r0,#0x5a
000020  d009              BEQ      |L14.54|
000022  dc04              BGT      |L14.46|
000024  2831              CMP      r0,#0x31
000026  d008              BEQ      |L14.58|
000028  2858              CMP      r0,#0x58
00002a  d106              BNE      |L14.58|
00002c  e003              B        |L14.54|
                  |L14.46|
00002e  2878              CMP      r0,#0x78
000030  d001              BEQ      |L14.54|
000032  287a              CMP      r0,#0x7a
000034  d101              BNE      |L14.58|
                  |L14.54|
;;;661    		{
;;;662    			case '1':
;;;663    				break;
;;;664    
;;;665    			case 'X':
;;;666    			case 'x':
;;;667    			case 'Z':
;;;668    			case 'z':
;;;669    				NVIC_SystemReset();		
000036  f7fffffe          BL       NVIC_SystemReset
                  |L14.58|
;;;670    				break;
;;;671    		}
;;;672    	}
;;;673    }
00003a  bd10              POP      {r4,pc}
;;;674    
                          ENDP

                  |L14.60|
                          DCD      0x40070000
                  |L14.64|
000040  696e7661          DCB      "invalid command\r\n",0
000044  6c696420
000048  636f6d6d
00004c  616e640d
000050  0a00    
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.compare_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  compare_buffer PROC
;;;103    
;;;104    void compare_buffer(uint8_t *src, uint8_t *des, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;105    {
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  4680              MOV      r8,r0
;;;106        uint16_t i = 0;	
00000a  2400              MOVS     r4,#0
;;;107    	
;;;108        for (i = 0; i < nBytes; i++)
;;;109        {
;;;110            if (src[i] != des[i])
;;;111            {
;;;112                printf("error idx : %4d : 0x%2X , 0x%2X\r\n", i , src[i],des[i]);
;;;113    			set_flag(flag_error , ENABLE);
00000c  4d0f              LDR      r5,|L15.76|
00000e  e00e              B        |L15.46|
                  |L15.16|
000010  f8182004          LDRB     r2,[r8,r4]            ;110
000014  5d3b              LDRB     r3,[r7,r4]            ;110
000016  429a              CMP      r2,r3                 ;110
000018  d007              BEQ      |L15.42|
00001a  4621              MOV      r1,r4                 ;112
00001c  a00c              ADR      r0,|L15.80|
00001e  f7fffffe          BL       __2printf
000022  6828              LDR      r0,[r5,#0]  ; BitFlag
000024  f0400008          ORR      r0,r0,#8
000028  6028              STR      r0,[r5,#0]  ; BitFlag
                  |L15.42|
00002a  1c64              ADDS     r4,r4,#1
00002c  b2a4              UXTH     r4,r4                 ;108
                  |L15.46|
00002e  42b4              CMP      r4,r6                 ;108
000030  dbee              BLT      |L15.16|
;;;114            }
;;;115        }
;;;116    
;;;117    	if (!is_flag_set(flag_error))
000032  6828              LDR      r0,[r5,#0]  ; BitFlag
000034  0700              LSLS     r0,r0,#28
000036  d407              BMI      |L15.72|
;;;118    	{
;;;119        	printf("%s finish \r\n" , __FUNCTION__);	
000038  490e              LDR      r1,|L15.116|
00003a  a00f              ADR      r0,|L15.120|
00003c  f7fffffe          BL       __2printf
;;;120    		set_flag(flag_error , DISABLE);
000040  6828              LDR      r0,[r5,#0]  ; BitFlag
000042  f0200008          BIC      r0,r0,#8
000046  6028              STR      r0,[r5,#0]  ; BitFlag
                  |L15.72|
;;;121    	}
;;;122    
;;;123    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;124    
                          ENDP

                  |L15.76|
                          DCD      ||.data||
                  |L15.80|
000050  6572726f          DCB      "error idx : %4d : 0x%2X , 0x%2X\r\n",0
000054  72206964
000058  78203a20
00005c  25346420
000060  3a203078
000064  25325820
000068  2c203078
00006c  2532580d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0
                  |L15.116|
                          DCD      ||.constdata||
                  |L15.120|
000078  25732066          DCB      "%s finish \r\n",0
00007c  696e6973
000080  68200d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.copy_buffer||, CODE, READONLY, ALIGN=1

                  copy_buffer PROC
;;;140    
;;;141    void copy_buffer(void *dest, void *src, unsigned int size)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143        uint8_t *pu8Src, *pu8Dest;
;;;144        unsigned int i;
;;;145        
;;;146        pu8Dest = (uint8_t *)dest;
;;;147        pu8Src  = (uint8_t *)src;
;;;148    
;;;149    
;;;150    	#if 0
;;;151    	  while (size--)
;;;152    	    *pu8Dest++ = *pu8Src++;
;;;153    	#else
;;;154        for (i = 0; i < size; i++)
000002  2300              MOVS     r3,#0
000004  e002              B        |L16.12|
                  |L16.6|
;;;155            pu8Dest[i] = pu8Src[i];
000006  5ccc              LDRB     r4,[r1,r3]
000008  54c4              STRB     r4,[r0,r3]
00000a  1c5b              ADDS     r3,r3,#1
                  |L16.12|
00000c  4293              CMP      r3,r2                 ;154
00000e  d3fa              BCC      |L16.6|
;;;156    	#endif
;;;157    }
000010  bd10              POP      {r4,pc}
;;;158    
                          ENDP


                          AREA ||i.dump_buffer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dump_buffer PROC
;;;158    
;;;159    void dump_buffer(uint8_t *pucBuff, int nBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;160    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;161        uint16_t i = 0;
000006  2400              MOVS     r4,#0
;;;162        
;;;163        printf("dump_buffer : %2d\r\n" , nBytes);    
000008  a00b              ADR      r0,|L17.56|
00000a  f7fffffe          BL       __2printf
;;;164        for (i = 0 ; i < nBytes ; i++)
00000e  e00c              B        |L17.42|
                  |L17.16|
;;;165        {
;;;166            printf("0x%2X," , pucBuff[i]);
000010  5d31              LDRB     r1,[r6,r4]
000012  a00e              ADR      r0,|L17.76|
000014  f7fffffe          BL       __2printf
;;;167            if ((i+1)%8 ==0)
000018  0760              LSLS     r0,r4,#29
00001a  f1b04f60          CMP      r0,#0xe0000000
00001e  d102              BNE      |L17.38|
;;;168            {
;;;169                printf("\r\n");
000020  a00c              ADR      r0,|L17.84|
000022  f7fffffe          BL       __2printf
                  |L17.38|
000026  1c64              ADDS     r4,r4,#1
000028  b2a4              UXTH     r4,r4                 ;164
                  |L17.42|
00002a  42ac              CMP      r4,r5                 ;164
00002c  dbf0              BLT      |L17.16|
;;;170            }            
;;;171        }
;;;172        printf("\r\n\r\n");
00002e  e8bd4070          POP      {r4-r6,lr}
000032  a009              ADR      r0,|L17.88|
000034  f7ffbffe          B.W      __2printf
;;;173    }
;;;174    
                          ENDP

                  |L17.56|
000038  64756d70          DCB      "dump_buffer : %2d\r\n",0
00003c  5f627566
000040  66657220
000044  3a202532
000048  640d0a00
                  |L17.76|
00004c  30782532          DCB      "0x%2X,",0
000050  582c00  
000053  00                DCB      0
                  |L17.84|
000054  0d0a00            DCB      "\r\n",0
000057  00                DCB      0
                  |L17.88|
000058  0d0a0d0a          DCB      "\r\n\r\n",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.dump_buffer_hex||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  dump_buffer_hex PROC
;;;174    
;;;175    void  dump_buffer_hex(uint8_t *pucBuff, int nBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;176    {
000004  460e              MOV      r6,r1
000006  4607              MOV      r7,r0
;;;177        int     nIdx, i;
;;;178    
;;;179        nIdx = 0;
000008  2500              MOVS     r5,#0
00000a  e025              B        |L18.88|
                  |L18.12|
;;;180        while (nBytes > 0)
;;;181        {
;;;182            printf("0x%04X  ", nIdx);
00000c  4629              MOV      r1,r5
00000e  a016              ADR      r0,|L18.104|
000010  f7fffffe          BL       __2printf
;;;183            for (i = 0; i < 16; i++)
000014  2400              MOVS     r4,#0
                  |L18.22|
;;;184                printf("%02X ", pucBuff[nIdx + i]);
000016  1928              ADDS     r0,r5,r4
000018  5c39              LDRB     r1,[r7,r0]
00001a  a016              ADR      r0,|L18.116|
00001c  f7fffffe          BL       __2printf
000020  1c64              ADDS     r4,r4,#1
000022  2c10              CMP      r4,#0x10              ;183
000024  dbf7              BLT      |L18.22|
;;;185            printf("  ");
000026  a015              ADR      r0,|L18.124|
000028  f7fffffe          BL       __2printf
;;;186            for (i = 0; i < 16; i++)
00002c  2400              MOVS     r4,#0
                  |L18.46|
;;;187            {
;;;188                if ((pucBuff[nIdx + i] >= 0x20) && (pucBuff[nIdx + i] < 127))
00002e  1928              ADDS     r0,r5,r4
000030  5c39              LDRB     r1,[r7,r0]
000032  f1a10020          SUB      r0,r1,#0x20
000036  285f              CMP      r0,#0x5f
000038  d203              BCS      |L18.66|
;;;189                    printf("%c", pucBuff[nIdx + i]);
00003a  a011              ADR      r0,|L18.128|
00003c  f7fffffe          BL       __2printf
000040  e002              B        |L18.72|
                  |L18.66|
;;;190                else
;;;191                    printf(".");
000042  a010              ADR      r0,|L18.132|
000044  f7fffffe          BL       __2printf
                  |L18.72|
000048  1c64              ADDS     r4,r4,#1
00004a  1e76              SUBS     r6,r6,#1
00004c  2c10              CMP      r4,#0x10              ;186
00004e  dbee              BLT      |L18.46|
;;;192                nBytes--;
;;;193            }
;;;194            nIdx += 16;
;;;195            printf("\n");
000050  a00d              ADR      r0,|L18.136|
000052  3510              ADDS     r5,r5,#0x10
000054  f7fffffe          BL       __2printf
                  |L18.88|
000058  2e00              CMP      r6,#0                 ;180
00005a  dcd7              BGT      |L18.12|
;;;196        }
;;;197        printf("\n");
00005c  e8bd41f0          POP      {r4-r8,lr}
000060  a009              ADR      r0,|L18.136|
000062  f7ffbffe          B.W      __2printf
;;;198    }
;;;199    
                          ENDP

000066  0000              DCW      0x0000
                  |L18.104|
000068  30782530          DCB      "0x%04X  ",0
00006c  34582020
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L18.116|
000074  25303258          DCB      "%02X ",0
000078  2000    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L18.124|
00007c  202000            DCB      "  ",0
00007f  00                DCB      0
                  |L18.128|
000080  256300            DCB      "%c",0
000083  00                DCB      0
                  |L18.132|
000084  2e00              DCB      ".",0
000086  00                DCB      0
000087  00                DCB      0
                  |L18.136|
000088  0a00              DCB      "\n",0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;93     
;;;94     uint32_t get_tick(void)
000000  4801              LDR      r0,|L19.8|
;;;95     {
;;;96     	return (counter_tick);
000002  6840              LDR      r0,[r0,#4]  ; counter_tick
;;;97     }
000004  4770              BX       lr
;;;98     
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      ||.data||

                          AREA ||i.loop||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_x
                          REQUIRE _printf_c
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  loop PROC
;;;537    
;;;538    void loop(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;539    {
;;;540    
;;;541        /* Add data processing code */
;;;542        #if defined (ENABLE_UART1)     
;;;543        if (UART1_P.g_u32comRbytes)
000002  4c23              LDR      r4,|L20.144|
000004  6c23              LDR      r3,[r4,#0x40]         ;539  ; UART1_P
000006  b1ab              CBZ      r3,|L20.52|
;;;544        {        
;;;545            UART1_P.tmp = UART1_P.g_u32comRtail;
000008  6ca1              LDR      r1,[r4,#0x48]  ; UART1_P
00000a  b28a              UXTH     r2,r1
00000c  f8a42054          STRH     r2,[r4,#0x54]
;;;546    
;;;547            if (UART1_P.g_u32comRhead != UART1_P.tmp)
000010  6c60              LDR      r0,[r4,#0x44]  ; UART1_P
000012  4290              CMP      r0,r2
000014  d00e              BEQ      |L20.52|
000016  e9cd0100          STRD     r0,r1,[sp,#0]
;;;548            {
;;;549                printf("UART1:%c[0x%2X](Rbytes:%2d,Rhead:%2d,Rtail:%2d)\r\n", 
00001a  5c21              LDRB     r1,[r4,r0]
00001c  a01d              ADR      r0,|L20.148|
00001e  460a              MOV      r2,r1
000020  f7fffffe          BL       __2printf
;;;550                UART1_P.g_u8RecData[UART1_P.g_u32comRhead],
;;;551                UART1_P.g_u8RecData[UART1_P.g_u32comRhead],            
;;;552                UART1_P.g_u32comRbytes,
;;;553                UART1_P.g_u32comRhead,
;;;554                UART1_P.g_u32comRtail);
;;;555    
;;;556                UART1_P.g_u32comRhead = (UART1_P.g_u32comRhead == (RXBUFSIZE - 1)) ? 0 : (UART1_P.g_u32comRhead + 1);
000024  6c60              LDR      r0,[r4,#0x44]  ; UART1_P
000026  283f              CMP      r0,#0x3f
000028  d02d              BEQ      |L20.134|
00002a  1c40              ADDS     r0,r0,#1
                  |L20.44|
;;;557                UART1_P.g_u32comRbytes--;
00002c  6460              STR      r0,[r4,#0x44]  ; UART1_P
00002e  6c20              LDR      r0,[r4,#0x40]  ; UART1_P
000030  1e40              SUBS     r0,r0,#1
000032  6420              STR      r0,[r4,#0x40]  ; UART1_P
                  |L20.52|
;;;558            }
;;;559        }
;;;560        #endif
;;;561    
;;;562        #if defined (ENABLE_UART2) 
;;;563        if (UART2_P.g_u32comRbytes)
000034  4c16              LDR      r4,|L20.144|
000036  345c              ADDS     r4,r4,#0x5c
000038  6c20              LDR      r0,[r4,#0x40]  ; UART2_P
00003a  b198              CBZ      r0,|L20.100|
;;;564        {        
;;;565            UART2_P.tmp = UART2_P.g_u32comRtail;
00003c  f8b40048          LDRH     r0,[r4,#0x48]  ; UART2_P
000040  b280              UXTH     r0,r0
000042  f8a40054          STRH     r0,[r4,#0x54]
;;;566    
;;;567            if (UART2_P.g_u32comRhead != UART2_P.tmp)
000046  6c61              LDR      r1,[r4,#0x44]  ; UART2_P
000048  4281              CMP      r1,r0
00004a  d00b              BEQ      |L20.100|
;;;568            {
;;;569                #if 1
;;;570                printf("UART2:0x%2X\r\n", UART2_P.g_u8RecData[UART2_P.g_u32comRhead]);
00004c  5c61              LDRB     r1,[r4,r1]
00004e  a01e              ADR      r0,|L20.200|
000050  f7fffffe          BL       __2printf
;;;571                #else
;;;572                printf("UART2:%c[0x%2X](Rbytes:%2d,Rhead:%2d,Rtail:%2d)\r\n", 
;;;573                UART2_P.g_u8RecData[UART2_P.g_u32comRhead],
;;;574                UART2_P.g_u8RecData[UART2_P.g_u32comRhead],            
;;;575                UART2_P.g_u32comRbytes,
;;;576                UART2_P.g_u32comRhead,
;;;577                UART2_P.g_u32comRtail);            
;;;578                #endif
;;;579                
;;;580                UART2_P.g_u32comRhead = (UART2_P.g_u32comRhead == (RXBUFSIZE - 1)) ? 0 : (UART2_P.g_u32comRhead + 1);
000054  6c60              LDR      r0,[r4,#0x44]  ; UART2_P
000056  283f              CMP      r0,#0x3f
000058  d017              BEQ      |L20.138|
00005a  1c40              ADDS     r0,r0,#1
                  |L20.92|
;;;581                UART2_P.g_u32comRbytes--;
00005c  6460              STR      r0,[r4,#0x44]  ; UART2_P
00005e  6c20              LDR      r0,[r4,#0x40]  ; UART2_P
000060  1e40              SUBS     r0,r0,#1
000062  6420              STR      r0,[r4,#0x40]  ; UART2_P
                  |L20.100|
;;;582            }
;;;583        }
;;;584        #endif   
;;;585    
;;;586        if (is_flag_set(flag_UART1_RX_end))
000064  480a              LDR      r0,|L20.144|
000066  3808              SUBS     r0,r0,#8
000068  6801              LDR      r1,[r0,#0]  ; BitFlag
00006a  0789              LSLS     r1,r1,#30
00006c  d503              BPL      |L20.118|
;;;587        {
;;;588            set_flag(flag_UART1_RX_end, DISABLE);
00006e  6801              LDR      r1,[r0,#0]  ; BitFlag
000070  f0210102          BIC      r1,r1,#2
000074  6001              STR      r1,[r0,#0]  ; BitFlag
                  |L20.118|
;;;589    
;;;590            // printf("UART1_RX : \r\n");
;;;591    
;;;592            // dump_buffer_hex(UART1_RxBuffer,DATA_NUM);
;;;593    
;;;594            // reset_buffer(UART1_RxBuffer,0x00,DATA_NUM);     
;;;595            // UART1_RX_PDMA_set();   
;;;596            
;;;597        }
;;;598    
;;;599        if (is_flag_set(flag_UART2_RX_end))
000076  6801              LDR      r1,[r0,#0]  ; BitFlag
000078  0749              LSLS     r1,r1,#29
00007a  d503              BPL      |L20.132|
;;;600        {
;;;601            set_flag(flag_UART2_RX_end, DISABLE);
00007c  6801              LDR      r1,[r0,#0]  ; BitFlag
00007e  f0210104          BIC      r1,r1,#4
000082  6001              STR      r1,[r0,#0]  ; BitFlag
                  |L20.132|
;;;602    
;;;603            // printf("UART2_RX : \r\n");
;;;604    
;;;605            // dump_buffer_hex(UART2_RxBuffer,DATA_NUM);
;;;606    
;;;607            // reset_buffer(UART2_RxBuffer,0x00,DATA_NUM);   
;;;608            // UART2_RX_PDMA_set();   
;;;609            
;;;610        }
;;;611    }
000084  bd1c              POP      {r2-r4,pc}
                  |L20.134|
000086  2000              MOVS     r0,#0                 ;556
000088  e7d0              B        |L20.44|
                  |L20.138|
00008a  2000              MOVS     r0,#0                 ;580
00008c  e7e6              B        |L20.92|
;;;612    
                          ENDP

00008e  0000              DCW      0x0000
                  |L20.144|
                          DCD      ||.data||+0x8
                  |L20.148|
000094  55415254          DCB      "UART1:%c[0x%2X](Rbytes:%2d,Rhead:%2d,Rtail:%2d)\r\n",0
000098  313a2563
00009c  5b307825
0000a0  32585d28
0000a4  52627974
0000a8  65733a25
0000ac  32642c52
0000b0  68656164
0000b4  3a253264
0000b8  2c527461
0000bc  696c3a25
0000c0  3264290d
0000c4  0a00    
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L20.200|
0000c8  55415254          DCB      "UART2:0x%2X\r\n",0
0000cc  323a3078
0000d0  2532580d
0000d4  0a00    
0000d6  00                DCB      0
0000d7  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;811    
;;;812    int main()
000000  f7fffffe          BL       SYS_Init
;;;813    {
;;;814        SYS_Init();
;;;815    
;;;816    	UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;817    	Custom_Init();	
000008  f7fffffe          BL       Custom_Init
;;;818    	TIMER1_Init();
00000c  f7fffffe          BL       TIMER1_Init
;;;819    
;;;820        UART_PDMA_Init();
000010  f7fffffe          BL       UART_PDMA_Init
;;;821        UART1_UART2_Init();
000014  f7fffffe          BL       UART1_UART2_Init
                  |L21.24|
;;;822    
;;;823        /* Got no where to go, just loop forever */
;;;824        while(1)
;;;825        {
;;;826            loop();
000018  f7fffffe          BL       loop
00001c  e7fc              B        |L21.24|
;;;827    
;;;828        }
;;;829    }
;;;830    
                          ENDP


                          AREA ||i.reset_buffer||, CODE, READONLY, ALIGN=1

                  reset_buffer PROC
;;;124    
;;;125    void reset_buffer(void *dest, unsigned int val, unsigned int size)
000000  b2c9              UXTB     r1,r1
;;;126    {
000002  e001              B        |L22.8|
                  |L22.4|
;;;127        uint8_t *pu8Dest;
;;;128    //    unsigned int i;
;;;129        
;;;130        pu8Dest = (uint8_t *)dest;
;;;131    
;;;132    	#if 1
;;;133    	while (size-- > 0)
;;;134    		*pu8Dest++ = val;
000004  f8001b01          STRB     r1,[r0],#1
                  |L22.8|
000008  1e52              SUBS     r2,r2,#1
00000a  d2fb              BCS      |L22.4|
;;;135    	#else
;;;136    	memset(pu8Dest, val, size * (sizeof(pu8Dest[0]) ));
;;;137    	#endif
;;;138    	
;;;139    }
00000c  4770              BX       lr
;;;140    
                          ENDP


                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;98     
;;;99     void set_tick(uint32_t t)
000000  4901              LDR      r1,|L23.8|
;;;100    {
;;;101    	counter_tick = t;
000002  6048              STR      r0,[r1,#4]  ; counter_tick
;;;102    }
000004  4770              BX       lr
;;;103    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      ||.data||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;88     
;;;89     void tick_counter(void)
000000  4802              LDR      r0,|L24.12|
;;;90     {
;;;91     	counter_tick++;
000002  6841              LDR      r1,[r0,#4]  ; counter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6041              STR      r1,[r0,#4]  ; counter_tick
;;;92     }
000008  4770              BX       lr
;;;93     
                          ENDP

00000a  0000              DCW      0x0000
                  |L24.12|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  DMA_UART1DESC
                          %        32
                  DMA_UART2DESC
                          %        32

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  636f6d70          DCB      0x63,0x6f,0x6d,0x70
000004  6172655f          DCB      0x61,0x72,0x65,0x5f
000008  62756666          DCB      0x62,0x75,0x66,0x66
00000c  657200            DCB      0x65,0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  BitFlag
                          DCD      0x00000000
                  counter_tick
                          DCD      0x00000000
                  UART1_P
000008  00000000          DCB      0x00,0x00,0x00,0x00
                          %        60
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x0000001f
                          DCD      0x00000000
00005c  0000              DCW      0x0000
00005e  0000              DCB      0x00,0x00
                          DCD      0x00000000
                  UART2_P
000064  00000000          DCB      0x00,0x00,0x00,0x00
                          %        60
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x0000001f
                          DCD      0x00000000
0000b8  0000              DCW      0x0000
0000ba  0000              DCB      0x00,0x00
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____RRX|
#line 587
|__asm___6_main_c_BitFlag____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
